<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sigil</name>
    </assembly>
    <members>
        <member name="T:Sigil.Emit`1">
            <summary>
            Helper for CIL generation that fails as soon as a sequence of instructions
            can be shown to be invalid.
            </summary>
            <typeparam name="DelegateType">The type of delegate being built</typeparam>
        </member>
        <member name="M:Sigil.Emit`1.Add">
            <summary>
            Pops two arguments off the stack, adds them, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.AddOverflow">
            <summary>
            Pops two arguments off the stack, adds them, and pushes the result.
            
            Throws an OverflowException if the result overflows the destination type.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedAddOverflow">
            <summary>
            Pops two arguments off the stack, adds them as if they were unsigned, and pushes the result.
            
            Throws an OverflowException if the result overflows the destination type.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Divide">
            <summary>
            Pops two arguments off the stack, divides the second by the first, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedDivide">
            <summary>
            Pops two arguments off the stack, divides the second by the first as if they were unsigned, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Multiply">
            <summary>
            Pops two arguments off the stack, multiplies them, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.MultiplyOverflow">
            <summary>
            Pops two arguments off the stack, multiplies them, and pushes the result.
            
            Throws an OverflowException if the result overflows the destination type.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedMultiplyOverflow">
            <summary>
            Pops two arguments off the stack, multiplies them as if they were unsigned, and pushes the result.
            
            Throws an OverflowException if the result overflows the destination type.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Remainder">
            <summary>
            Pops two arguments off the stack, calculates the remainder of the second divided by the first, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedRemainder">
            <summary>
            Pops two arguments off the stack, calculates the remainder of the second divided by the first as if both were unsigned, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Subtract">
            <summary>
            Pops two arguments off the stack, subtracts the first from the second, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.SubtractOverflow">
            <summary>
            Pops two arguments off the stack, subtracts the first from the second, and pushes the result.
            
            Throws an OverflowException if the result overflows the destination type.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedSubtractOverflow">
            <summary>
            Pops two arguments off the stack, subtracts the first from the second as if they were unsigned, and pushes the result.
            
            Throws an OverflowException if the result overflows the destination type.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Negate">
            <summary>
            Pops an argument off the stack, negates it, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.And">
            <summary>
            Pops two arguments off the stack, performs a bitwise and, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Or">
            <summary>
            Pops two arguments off the stack, performs a bitwise or, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Xor">
            <summary>
            Pops two arguments off the stack, performs a bitwise xor, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Not">
            <summary>
            Pops one argument off the stack, performs a bitwise inversion, and pushes the result.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.ShiftLeft">
            <summary>
            Pops two arguments off the stack, shifts the second value left by the first value.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.ShiftRight">
            <summary>
            Pops two arguments off the stack, shifts the second value right by the first value.
            
            Sign extends from the left.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedShiftRight">
            <summary>
            Pops two arguments off the stack, shifts the second value right by the first value.
            
            Acts as if the value were unsigned, zeros always coming in from the left.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Break">
            <summary>
            Emits a break instruction for use with a debugger.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes a void return and no parameters.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``1(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and no parameters.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``2(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``3(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``4(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``5(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``6(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``7(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``8(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``9(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``10(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``11(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``12(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``13(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``14(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``15(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``16(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect``17(System.Reflection.CallingConventions)">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            
            This helper assumes ReturnType as a return and parameters of the types given in ParameterType*.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallIndirect(System.Reflection.CallingConventions,System.Type,System.Type[])">
            <summary>
            Pops a pointer to a method, and then all it's arguments (in reverse order, left-most parameter is deepest on the stack) and calls
            invokes the method pointer.  If the method returns a non-void result, it is pushed onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CastClass``1">
            <summary>
            Cast a reference on the stack to the given reference type.
            
            If the cast is not legal, a CastClassException will be thrown at runtime.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CastClass(System.Type)">
            <summary>
            Cast a reference on the stack to the given reference type.
            
            If the cast is not legal, a CastClassException will be thrown at runtime.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Box``1">
            <summary>
            Boxes the given value type on the stack, converting it into a reference.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Box(System.Type)">
            <summary>
            Boxes the given value type on the stack, converting it into a reference.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Branch(Sigil.Label)">
            <summary>
            Unconditionally branches to the given label.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.GetStack(System.Int32)">
            <summary>
            Returns the information currently on the stack, ignoring the top "skip" items; the types are returned
            top-to-bottom, making this directly usable from MarkLabel.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BranchIfEqual(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, if both are equal branches to the given label.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedBranchIfNotEqual(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, if they are not equal (when treated as unsigned values) branches to the given label.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BranchIfGreaterOrEqual(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, branches to the given label if the second value is greater than or equal to the first value.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedBranchIfGreaterOrEqual(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, branches to the given label if the second value is greater than or equal to the first value (when treated as unsigned values).
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BranchIfGreater(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, branches to the given label if the second value is greater than the first value.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedBranchIfGreater(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, branches to the given label if the second value is greater than the first value (when treated as unsigned values).
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BranchIfLessOrEqual(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, branches to the given label if the second value is less than or equal to the first value.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedBranchIfLessOrEqual(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, branches to the given label if the second value is less than or equal to the first value (when treated as unsigned values).
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BranchIfLess(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, branches to the given label if the second value is less than the first value.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedBranchIfLess(Sigil.Label)">
            <summary>
            Pops two arguments from the stack, branches to the given label if the second value is less than the first value (when treated as unsigned values).
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BranchIfFalse(Sigil.Label)">
            <summary>
            Pops one argument from the stack, branches to the given label if the value is false.
            
            A value is false if it is zero or null.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BranchIfTrue(Sigil.Label)">
            <summary>
            Pops one argument from the stack, branches to the given label if the value is true.
            
            A value is true if it is non-zero or non-null.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Call(System.Reflection.MethodInfo)">
            <summary>
            Calls the given method.  Pops its arguments in reverse order (left-most deepest in the stack), and pushes the return value if it is non-void.
            
            If the given method is an instance method, the `this` reference should appear before any parameters.
            
            Call does not respect overrides, the implementation defined by the given MethodInfo is what will be called at runtime.
            
            To call overrides of instance methods, use CallVirtual.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CallVirtual(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Calls the given method virtually.  Pops its arguments in reverse order (left-most deepest in the stack), and pushes the return value if it is non-void.
            
            The `this` reference should appear before any arguments (deepest in the stack).
            
            The method invoked at runtime is determined by the type of the `this` reference.
            
            If the method invoked shouldn't vary (or if the method is static), use Call instead.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CompareEqual">
            <summary>
            Pops two values from the stack, and pushes a 1 if they are equal and 0 if they are not.
            
            New value on the stack is an Int32.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CompareGreaterThan">
            <summary>
            Pops two arguments from the stack, pushes a 1 if the second value is greater than the first value and a 0 otherwise.
            
            New value on the stack is an Int32.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedCompareGreaterThan">
            <summary>
            Pops two arguments from the stack, pushes a 1 if the second value is greater than the first value (as unsigned values) and a 0 otherwise.
            
            New value on the stack is an Int32.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CompareLessThan">
            <summary>
            Pops two arguments from the stack, pushes a 1 if the second value is less than the first value and a 0 otherwise.
            
            New value on the stack is an Int32.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedCompareLessThan">
            <summary>
            Pops two arguments from the stack, pushes a 1 if the second value is less than the first value (as unsigned values) and a 0 otherwise.
            
            New value on the stack is an Int32.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Convert``1">
            <summary>
            Convert a value on the stack to the given non-character primitive type.
            
            Primitives are int8, uint8, int16, uint16, int32, uint32, int64, uint64, float, double, native int (IntPtr), and unsigned native int (UIntPtr). 
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Convert(System.Type)">
            <summary>
            Convert a value on the stack to the given non-character primitive type.
            
            Primitives are int8, uint8, int16, uint16, int32, uint32, int64, uint64, float, double, native int (IntPtr), and unsigned native int (UIntPtr). 
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.ConvertOverflow``1">
            <summary>
            Convert a value on the stack to the given non-character, non-float, non-double primitive type.
            If the conversion would overflow at runtime, an OverflowException is thrown.
            
            Primitives are int8, uint8, int16, uint16, int32, uint32, int64, uint64, float, double, native int (IntPtr), and unsigned native int (UIntPtr). 
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.ConvertOverflow(System.Type)">
            <summary>
            Convert a value on the stack to the given non-character, non-float, non-double primitive type.
            If the conversion would overflow at runtime, an OverflowException is thrown.
            
            Primitives are int8, uint8, int16, uint16, int32, uint32, int64, uint64, float, double, native int (IntPtr), and unsigned native int (UIntPtr). 
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedConvertOverflow``1">
            <summary>
            Convert a value on the stack to the given non-character, non-float, non-double primitive type as if it were unsigned.
            If the conversion would overflow at runtime, an OverflowException is thrown.
            
            Primitives are int8, uint8, int16, uint16, int32, uint32, int64, uint64, float, double, native int (IntPtr), and unsigned native int (UIntPtr). 
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedConvertOverflow(System.Type)">
            <summary>
            Convert a value on the stack to the given non-character, non-float, non-double primitive type as if it were unsigned.
            If the conversion would overflow at runtime, an OverflowException is thrown.
            
            Primitives are int8, uint8, int16, uint16, int32, uint32, int64, uint64, float, double, native int (IntPtr), and unsigned native int (UIntPtr). 
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnsignedConvertToFloat">
            <summary>
            Converts a primitive type on the stack to a float, as if it were unsigned.
            
            Primitives are int8, uint8, int16, uint16, int32, uint32, int64, uint64, float, double, native int (IntPtr), and unsigned native int (UIntPtr).
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CopyBlock(System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Expects a destination pointer, a source pointer, and a length on the stack.  Pops all three values.
            
            Copies length bytes from destination to the source.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CopyObject``1">
            <summary>
            Takes a destination pointer, a source pointer as arguments.  Pops both off the stack.
            
            Copies the given value type from the source to the destination.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CopyObject(System.Type)">
            <summary>
            Takes a destination pointer, a source pointer as arguments.  Pops both off the stack.
            
            Copies the given value type from the source to the destination.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.AsShorthand">
            <summary>
            Returns a proxy for this Emit that exposes method names that more closely
            match the fields on System.Reflection.Emit.OpCodes.
            
            IF you're well versed in ILGenerator, the shorthand version may be easier to use.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Instructions">
            <summary>
            Returns a string representation of the CIL opcodes written to this Emit to date.
            
            This method is meant for debugging purposes only.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.ILOffset">
            <summary>
            Returns the current instruction offset (effectively, the length of the CIL stream to date).
            
            This does not necessarily increase monotonically, as rewrites can cause it to shrink.
            
            Likewise the effect of any given call is not guaranteed to be the same under all circumstance, as current and future
            state may influence opcode choice.
            
            This method is meant for debugging purposes only.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CreateDelegate(System.String@)">
            <summary>
            Converts the CIL stream into a delegate.
            
            Validation that cannot be run until a method is finished is run, and various instructions
            are re-written to choose "optimal" forms (Br may become Br_S, for example).
            
            Once this method is called the Emit may no longer be modified.
            
            `instructions` will be set to a representation of the instructions making up the returned delegate.
            Note that this string is typically *not* enough to regenerate the delegate, it is available for
            debugging purposes only.  Consumers may find it useful to log the instruction stream in case
            the returned delegate fails validation (indicative of a bug in Sigil) or
            behaves unexpectedly (indicative of a logic bug in the consumer code).
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CreateDelegate">
            <summary>
            Converts the CIL stream into a delegate.
            
            Validation that cannot be run until a method is finished is run, and various instructions
            are re-written to choose "optimal" forms (Br may become Br_S, for example).
            
            Once this method is called the Emit may no longer be modified.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CreateMethod(System.String@)">
            <summary>
            Writes the CIL stream out to the MethodBuilder used to create this Emit.
            
            Validation that cannot be run until a method is finished is run, and various instructions
            are re-written to choose "optimal" forms (Br may become Br_S, for example).
            
            Once this method is called the Emit may no longer be modified.
            
            Returns a MethodBuilder, which can be used to define overrides or for further inspection.
            
            `instructions` will be set to a representation of the instructions making up the returned method.
            Note that this string is typically *not* enough to regenerate the method, it is available for
            debugging purposes only.  Consumers may find it useful to log the instruction stream in case
            the returned method fails validation (indicative of a bug in Sigil) or
            behaves unexpectedly (indicative of a logic bug in the consumer code).
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CreateMethod">
            <summary>
            Writes the CIL stream out to the MethodBuilder used to create this Emit.
            
            Validation that cannot be run until a method is finished is run, and various instructions
            are re-written to choose "optimal" forms (Br may become Br_S, for example).
            
            Once this method is called the Emit may no longer be modified.
            
            Returns a MethodBuilder, which can be used to define overrides or for further inspection.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CreateConstructor(System.String@)">
            <summary>
            Writes the CIL stream out to the ConstructorBuilder used to create this Emit.
            
            Validation that cannot be run until a method is finished is run, and various instructions
            are re-written to choose "optimal" forms (Br may become Br_S, for example).
            
            Once this method is called the Emit may no longer be modified.
            
            Returns a ConstructorBuilder, which can be used to define overrides or for further inspection.
            
            `instructions` will be set to a representation of the instructions making up the returned constructor.
            Note that this string is typically *not* enough to regenerate the constructor, it is available for
            debugging purposes only.  Consumers may find it useful to log the instruction stream in case
            the returned constructor fails validation (indicative of a bug in Sigil) or
            behaves unexpectedly (indicative of a logic bug in the consumer code).
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CreateConstructor">
            <summary>
            Writes the CIL stream out to the ConstructorBuilder used to create this Emit.
            
            Validation that cannot be run until a method is finished is run, and various instructions
            are re-written to choose "optimal" forms (Br may become Br_S, for example).
            
            Once this method is called the Emit may no longer be modified.
            
            Returns a ConstructorBuilder, which can be used to define overrides or for further inspection.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewDynamicMethod(System.String,System.Reflection.Emit.ModuleBuilder)">
            <summary>
            Creates a new Emit, optionally using the provided name and module for the inner DynamicMethod.
            
            If name is not defined, a sane default is generated.
            
            If module is not defined, a module with the same trust as the executing assembly is used instead.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewDynamicMethod(System.Type,System.String)">
            <summary>
            Creates a new Emit, optionally using the provided name and owner for the inner DynamicMethod.
            
            If name is not defined, a sane default is generated.
            
            If owner is not defined, a module with the same trust as the executing assembly is used instead.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BuildMethod(System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Boolean)">
            <summary>
            Creates a new Emit, suitable for building a method on the given TypeBuilder.
            
            The DelegateType and MethodBuilder must agree on return types, parameter types, and parameter counts.
            
            If you intend to use unveriable code, you must set allowUnverifiableCode to true.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BuildStaticMethod(System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes,System.Boolean)">
            <summary>
            Convenience method for creating static methods.
            
            Equivalent to calling to BuildMethod, but with MethodAttributes.Static set and CallingConventions.Standard.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BuildInstanceMethod(System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes,System.Boolean)">
            <summary>
            Convenience method for creating instance methods.
            
            Equivalent to calling to BuildMethod, but with CallingConventions.HasThis.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BuildConstructor(System.Reflection.Emit.TypeBuilder,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Boolean)">
            <summary>
            Creates a new Emit, suitable for building a constructo on the given TypeBuilder.
            
            The DelegateType and TypeBuilder must agree on parameter types and parameter counts.
            
            If you intend to use unveriable code, you must set allowUnverifiableCode to true.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Duplicate">
            <summary>
            Pushes a copy of the current top value on the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.InitializeBlock(System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Expects a pointer, an initialization value, and a count on the stack.  Pops all three.
            
            Writes the initialization value to count bytes at the passed pointer.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.InitializeObject``1">
            <summary>
            Expects an instance of the type to be initialized on the stack.
            
            Initializes all the fields on a value type to null or an appropriate zero value.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.InitializeObject(System.Type)">
            <summary>
            Expects an instance of the type to be initialized on the stack.
            
            Initializes all the fields on a value type to null or an appropriate zero value.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.IsInstance``1">
            <summary>
            Pops a value from the stack and casts to the given type if possible pushing the result, otherwise pushes a null.
            
            This is analogous to C#'s `as` operator.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.IsInstance(System.Type)">
            <summary>
            Pops a value from the stack and casts to the given type if possible pushing the result, otherwise pushes a null.
            
            This is analogous to C#'s `as` operator.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Jump(System.Reflection.MethodInfo)">
            <summary>
            Transfers control to another method.
            
            The parameters and calling convention of method must match the current one's.
            
            The stack must be empty to jump.
            
            Like the branching instructions, Jump cannot leave exception blocks.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.DefineLabel(System.String)">
            <summary>
            Defines a new label.
            
            This label can be used for branching, leave, and switch instructions.
            
            A label must be marked exactly once after being defined, using the MarkLabel() method.        
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.DefineLabel(Sigil.Label@,System.String)">
            <summary>
            Defines a new label.
            
            This label can be used for branching, leave, and switch instructions.
            
            A label must be marked exactly once after being defined, using the MarkLabel() method.        
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.MarkLabel(Sigil.Label,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Marks a label in the instruction stream.
            
            When branching, leaving, or switching with a label control will be transfered to where it was *marked* not defined.
            
            Label's can only be marked once, and *must* be marked before creating a delegate.
            
            Logically after a Branch or Leave instruction, a stack assertion is required to continue emiting.  The stack
            is assumed to match that state in these cases.
            
            In all other cases, a stack assertion is merely checked (and if failing, a verification exception is thrown).
            
            In the assertion, the top of the stack is the first (0-indexed, left-most) parameter.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Leave(Sigil.Label)">
            <summary>
            Leave an exception or catch block, branching to the given label.
            
            This instruction empties the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadArgument(System.UInt16)">
            <summary>
            Loads the argument at the given index (starting at 0) for the current method onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadArgumentAddress(System.UInt16)">
            <summary>
            Loads a pointer to the argument at index (starting at zero) onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.Boolean)">
            <summary>
            Push a 1 onto the stack if b is true, and 0 if false.
            
            Pushed values are int32s.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.Int32)">
            <summary>
            Push a constant int32 onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.UInt32)">
            <summary>
            Push a constant int32 onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.Int64)">
            <summary>
            Push a constant int64 onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.UInt64)">
            <summary>
            Push a constant int64 onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.Single)">
            <summary>
            Push a constant float onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.Double)">
            <summary>
            Push a constant double onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.String)">
            <summary>
            Push a constant string onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.Reflection.FieldInfo)">
            <summary>
            Push a constant RuntimeFieldHandle onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.Reflection.MethodInfo)">
            <summary>
            Push a constant RuntimeMethodHandle onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant``1">
            <summary>
            Push a constant RuntimeTypeHandle onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadConstant(System.Type)">
            <summary>
            Push a constant RuntimeTypeHandle onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadNull">
            <summary>
            Loads a null reference onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadElement">
            <summary>
            Expects a reference to an array and an index on the stack.
            
            Pops both, and pushes the element in the array at the index onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadElementAddress">
            <summary>
            Expects a reference to an array of the given element type and an index on the stack.
            
            Pops both, and pushes the address of the element at the given index.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadField(System.Reflection.FieldInfo,System.Nullable{System.Boolean},System.Nullable{System.Int32})">
            <summary>
            Loads a field onto the stack.
            
            Instance fields expect a reference on the stack, which is popped.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadFieldAddress(System.Reflection.FieldInfo)">
            <summary>
            Loads the address of the given field onto the stack.
            
            If the field is an instance field, a `this` reference is expected on the stack and will be popped.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadFunctionPointer(System.Reflection.MethodInfo)">
            <summary>
            Pushes a pointer to the given function onto the stack, as a native int.
            
            To resolve a method at runtime using an object, use LoadVirtualFunctionPointer instead.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadIndirect``1(System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a pointer from the stack and pushes the value (of the given type) at that address onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadIndirect(System.Type,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a pointer from the stack and pushes the value (of the given type) at that address onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadLength">
            <summary>
            Pops a reference to a rank 1 array off the stack, and pushes it's length onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadLocalAddress(Sigil.Local)">
            <summary>
            Pushes a pointer to the given local onto the stack.
            
            To create a local, use DeclareLocal.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadObject``1(System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a pointer from the stack, and pushes the given value type it points to onto the stack.
            
            For primitive and reference types, use LoadIndirect().
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadObject(System.Type,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a pointer from the stack, and pushes the given value type it points to onto the stack.
            
            For primitive and reference types, use LoadIndirect().
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadVirtualFunctionPointer(System.Reflection.MethodInfo)">
            <summary>
            Pops an object reference off the stack, and pushes a pointer to the given method's implementation on that object.
            
            For static or non-virtual functions, use LoadFunctionPointer
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LocalAllocate">
            <summary>
            Pops a size from the stack, allocates size bytes on the local dynamic memory pool, and pushes a pointer to the allocated block.
            
            LocalAllocate can only be called if the stack is empty aside from the size value.
            
            Memory allocated with LocalAllocate is released when the current method ends execution.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.DeclareLocal``1(System.String)">
            <summary>
            Declare a new local of the given type in the current method.
            
            Name is optional, and only provided for debugging purposes.  It has no
            effect on emitted IL.
            
            Be aware that each local takes some space on the stack, inefficient use of locals
            could lead to StackOverflowExceptions at runtime.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.DeclareLocal(System.Type,System.String)">
            <summary>
            Declare a new local of the given type in the current method.
            
            Name is optional, and only provided for debugging purposes.  It has no
            effect on emitted IL.
            
            Be aware that each local takes some space on the stack, inefficient use of locals
            could lead to StackOverflowExceptions at runtime.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.DeclareLocal``1(Sigil.Local@,System.String)">
            <summary>
            Declare a new local of the given type in the current method.
            
            Name is optional, and only provided for debugging purposes.  It has no
            effect on emitted IL.
            
            Be aware that each local takes some space on the stack, inefficient use of locals
            could lead to StackOverflowExceptions at runtime.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.DeclareLocal(System.Type,Sigil.Local@,System.String)">
            <summary>
            Declare a new local of the given type in the current method.
            
            Name is optional, and only provided for debugging purposes.  It has no
            effect on emitted IL.
            
            Be aware that each local takes some space on the stack, inefficient use of locals
            could lead to StackOverflowExceptions at runtime.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewArray``1">
            <summary>
            Pops a size from the stack, allocates a rank-1 array of the given type, and pushes a reference to the new array onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewArray(System.Type)">
            <summary>
            Pops a size from the stack, allocates a rank-1 array of the given type, and pushes a reference to the new array onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``1">
            <summary>
            Invokes the parameterless constructor of the given type, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``2">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``3">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``4">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``5">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``6">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``7">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``8">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``9">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``10">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``11">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``12">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``13">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``14">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``15">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``16">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject``17">
            <summary>
            Pops # of parameter arguments from the stack, invokes the the constructor of the given reference type that matches the given parameter types, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject(System.Type,System.Type[])">
            <summary>
            Pops parameterTypes.Length arguments from the stack, invokes the constructor on the given type that matches parameterTypes, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.NewObject(System.Reflection.ConstructorInfo)">
            <summary>
            Pops # of parameters to the given constructor arguments from the stack, invokes the constructor, and pushes a reference to the new object onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Nop">
            <summary>
            Emits an instruction that does nothing.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Pop">
            <summary>
            Removes the top value on the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.ReThrow">
            <summary>
            From within a catch block, rethrows the exception that caused the catch block to be entered.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Return">
            <summary>
            Ends the execution of the current method.
            
            If the current method does not return void, pops a value from the stack and returns it to the calling method.
            
            Return should leave the stack empty.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.SizeOf``1">
            <summary>
            Pushes the size of the given value type onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.SizeOf(System.Type)">
            <summary>
            Pushes the size of the given value type onto the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.StoreArgument(System.UInt16)">
            <summary>
            Pops a value off the stack and stores it into the argument to the current method identified by index.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.StoreElement">
            <summary>
            Pops a value, an index, and a reference to an array off the stack.  Places the given value into the given array at the given index.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.StoreField(System.Reflection.FieldInfo,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a value from the stack and stores it in the given field.
            
            If the field is an instance member, both a value and a reference to the instance are popped from the stack.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.StoreIndirect``1(System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a value of the given type and a pointer off the stack, and stores the value at the address in the pointer.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.StoreIndirect(System.Type,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a value of the given type and a pointer off the stack, and stores the value at the address in the pointer.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.StoreLocal(Sigil.Local)">
            <summary>
            Pops a value off the stack and stores it into the given local.
            
            To create a local, use DeclareLocal().
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.StoreObject``1(System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a value type and a pointer off of the stack and copies the given value to the given address.
            
            For primitive and reference types use StoreIndirect.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.StoreObject(System.Type,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Pops a value type and a pointer off of the stack and copies the given value to the given address.
            
            For primitive and reference types use StoreIndirect.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Switch(Sigil.Label[])">
            <summary>
            Pops a value off the stack and branches to the label at the index of that value in the given labels.
            
            If the value is out of range, execution falls through to the next instruction.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Throw">
            <summary>
            Pops a value off the stack and throws it as an exception.
            
            Throw expects the value to be or extend from a System.Exception.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginExceptionBlock">
            <summary>
            Start a new exception block.  This is roughly analogous to a `try` block in C#, but an exception block contains it's catch and finally blocks.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginExceptionBlock(Sigil.ExceptionBlock@)">
            <summary>
            Start a new exception block.  This is roughly analogous to a `try` block in C#, but an exception block contains it's catch and finally blocks.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.EndExceptionBlock(Sigil.ExceptionBlock)">
            <summary>
            Ends the given exception block.
            
            All catch and finally blocks associated with the given exception block must be ended before this method is called.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginCatchBlock``1(Sigil.ExceptionBlock)">
            <summary>
            Begins a catch block for the given exception type in the given exception block.
            
            The given exception block must still be open.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginCatchBlock``1(Sigil.ExceptionBlock,Sigil.CatchBlock@)">
            <summary>
            Begins a catch block for the given exception type in the given exception block.
            
            The given exception block must still be open.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginCatchAllBlock(Sigil.ExceptionBlock)">
             <summary>
             Begins a catch block for all exceptions in the given exception block
            
             The given exception block must still be open.
             
             Equivalent to BeginCatchBlock(typeof(Exception), forTry).
             </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginCatchAllBlock(Sigil.ExceptionBlock,Sigil.CatchBlock@)">
             <summary>
             Begins a catch block for all exceptions in the given exception block
            
             The given exception block must still be open.
             
             Equivalent to BeginCatchBlock(typeof(Exception), forTry).
             </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginCatchBlock(Sigil.ExceptionBlock,System.Type)">
            <summary>
            Begins a catch block for the given exception type in the given exception block.
            
            The given exception block must still be open.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginCatchBlock(Sigil.ExceptionBlock,System.Type,Sigil.CatchBlock@)">
            <summary>
            Begins a catch block for the given exception type in the given exception block.
            
            The given exception block must still be open.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.EndCatchBlock(Sigil.CatchBlock)">
            <summary>
            Ends the given catch block.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginFinallyBlock(Sigil.ExceptionBlock,Sigil.FinallyBlock@)">
            <summary>
            Begins a finally block on the given exception block.
            
            Only one finally block can be defined per exception block, and the block cannot appear within a catch block.
            
            The given exception block must still be open.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.BeginFinallyBlock(Sigil.ExceptionBlock)">
            <summary>
            Begins a finally block on the given exception block.
            
            Only one finally block can be defined per exception block, and the block cannot appear within a catch block.
            
            The given exception block must still be open.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.EndFinallyBlock(Sigil.FinallyBlock)">
            <summary>
            Ends the given finally block.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Unbox``1">
            <summary>
            Pops a boxed value from the stack and pushes a pointer to it's unboxed value.
            
            To load the value directly onto the stack, use UnboxAny().
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Unbox(System.Type)">
            <summary>
            Pops a boxed value from the stack and pushes a pointer to it's unboxed value.
            
            To load the value directly onto the stack, use UnboxAny().
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnboxAny``1">
            <summary>
            Pops a boxed value from the stack, unboxes it and pushes the value onto the stack.
            
            To get an address for the unboxed value instead, use Unbox().
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.UnboxAny(System.Type)">
            <summary>
            Pops a boxed value from the stack, unboxes it and pushes the value onto the stack.
            
            To get an address for the unboxed value instead, use Unbox().
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.Validate">
            <summary>
            Called to confirm that the IL emit'd to date can be turned into a delegate without error.
            
            Checks that the stack is empty, that all paths returns, that all labels are marked, etc. etc.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.CheckFinite">
            <summary>
            Throws an ArithmeticException on runtime if the value on the stack is not a finite number.
            
            This leaves the value checked on the stack, rather than popping it as might be expected.
            </summary>
        </member>
        <member name="M:Sigil.Emit`1.LoadLocal(Sigil.Local)">
            <summary>
            Loads the value in the given local onto the stack.
            
            To create a local, use DeclareLocal().
            </summary>
        </member>
        <member name="P:Sigil.Emit`1.AllowsUnverifiableCIL">
            <summary>
            Returns true if this Emit can make use of unverifiable instructions.
            </summary>
        </member>
        <member name="P:Sigil.Emit`1.MaxStackSize">
            <summary>
            Returns the maxmimum number of items on the stack for the IL stream created with the current emit.
            
            This is not the maximum that *can be placed*, but the maximum that actually are.
            </summary>
        </member>
        <member name="P:Sigil.Emit`1.Locals">
            <summary>
            Lookup for the locals currently in scope by name.
            
            Locals go out of scode when released (by calling Dispose() directly, or via  using) and go into scope
            immediately after a DeclareLocal()
            </summary>
        </member>
        <member name="P:Sigil.Emit`1.Labels">
            <summary>
            Lookup for declared labels by name.
            </summary>
        </member>
        <member name="T:Sigil.LabelLookup">
            <summary>
            Provides a way to lookup labels declared with an emit.
            </summary>
        </member>
        <member name="P:Sigil.LabelLookup.Item(System.String)">
            <summary>
            Returns the label with the given name.
            
            Throws KeyNotFoundException if no label by that name is found".
            </summary>
        </member>
        <member name="P:Sigil.LabelLookup.Count">
            <summary>
            Returns the number of labels declared
            </summary>
        </member>
        <member name="P:Sigil.LabelLookup.Names">
            <summary>
            Returns the names of all the declared labels
            </summary>
        </member>
        <member name="T:Sigil.NativeIntType">
            <summary>
            This type represents a "native int" on the stack.
            
            The size of native int varies depending on the architecture an assembly is executed on.
            Raw pointers are often of type native int.
            
            This type is exposed to allow for stack assertions containing native int via Emit.MarkLabel.
            </summary>
        </member>
        <member name="T:Sigil.NullType">
            <summary>
            This type represents a provably null value on the stack.
            
            Nulls typically arrive on the stack via LoadNull.
            
            Null can be assigned to any reference type safely, without the need for a CastClass.
            
            This type is exposed to allow for stack assertions containing null via Emit.MarkLabel.
            </summary>
        </member>
        <member name="T:Sigil.LocalLookup">
            <summary>
            Provides a way to lookup locals in scope by name.
            </summary>
        </member>
        <member name="P:Sigil.LocalLookup.Item(System.String)">
            <summary>
            Returns the local with the given name.
            
            Throws KeyNotFoundException if no local by that name is found".
            </summary>
        </member>
        <member name="P:Sigil.LocalLookup.Count">
            <summary>
            Returns the number of locals in scope
            </summary>
        </member>
        <member name="P:Sigil.LocalLookup.Names">
            <summary>
            Returns the names of all the locals in scope
            </summary>
        </member>
        <member name="T:Sigil.CatchBlock">
            <summary>
            Represents a catch block which appears in an ExceptionBlock.
            
            To create a CatchBlock, call BeginCatchBlock(Type) or BeginCatchAllBlock().
            </summary>
        </member>
        <member name="P:Sigil.CatchBlock.ExceptionBlock">
            <summary>
            The ExceptionBlock this CatchBlock appears in.
            </summary>
        </member>
        <member name="P:Sigil.CatchBlock.IsCatchAll">
            <summary>
            Returns true if this CatchBlock will catch all exceptions.
            
            This is equivalent to `catch(Exception e)` in C#.
            </summary>
        </member>
        <member name="P:Sigil.CatchBlock.ExceptionType">
            <summary>
            The type of exception being caught by this CatchBlock.
            
            When the CatchBlock is entered, an exception of this type will
            be pushed onto the stack.
            </summary>
        </member>
        <member name="T:Sigil.EmitShorthand`1">
            <summary>
            A version of Emit with shorter named versions of it's methods.
            
            Method names map more or less to OpCodes fields.
            </summary>
        </member>
        <member name="M:Sigil.EmitShorthand`1.AsLonghand">
            <summary>
            Returns the original Emit instance that AsShorthand() was called on.
            </summary>
        </member>
        <member name="M:Sigil.EmitShorthand`1.Instructions">
            <summary>
            Returns a string representation of the CIL opcodes written to this Emit to date.
            
            This method is meant for debugging purposes only.
            </summary>
        </member>
        <member name="M:Sigil.EmitShorthand`1.DeclareLocal``1(System.String)">
            <summary cref="M:Sigil.Emit`1.DeclareLocal``1(System.String)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.DeclareLocal``1(Sigil.Local@,System.String)">
            <summary cref="M:Sigil.Emit`1.DeclareLocal``1(System.String)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.DeclareLocal(System.Type,System.String)">
            <summary cref="M:Sigil.Emit`1.DeclareLocal(System.Type, System.String)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.DeclareLocal(System.Type,Sigil.Local@,System.String)">
            <summary cref="M:Sigil.Emit`1.DeclareLocal(System.Type, System.String)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.DefineLabel(System.String)">
            <summary cref="M:Sigil.Emit`1.DefineLabel(System.String)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.DefineLabel(Sigil.Label@,System.String)">
            <summary cref="M:Sigil.Emit`1.DefineLabel(System.String)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.MarkLabel(Sigil.Label,System.Collections.Generic.IEnumerable{System.Type})">
            <summary cref="M:Sigil.Emit`1.MarkLabel(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.BeginExceptionBlock">
            <summary cref="M:Sigil.Emit`1.BeginExceptionBlock" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.BeginExceptionBlock(Sigil.ExceptionBlock@)">
            <summary cref="M:Sigil.Emit`1.BeginExceptionBlock" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.BeginCatchBlock``1(Sigil.ExceptionBlock)">
            <summary cref="M:Sigil.Emit`1.BeginCatchBlock``1(Sigil.ExceptionBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.BeginCatchBlock``1(Sigil.ExceptionBlock,Sigil.CatchBlock@)">
            <summary cref="M:Sigil.Emit`1.BeginCatchBlock``1(Sigil.ExceptionBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.BeginCatchBlock(Sigil.ExceptionBlock,System.Type)">
            <summary cref="M:Sigil.Emit`1.BeginCatchBlock(System.Type, Sigil.ExceptionBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.BeginCatchBlock(Sigil.ExceptionBlock,System.Type,Sigil.CatchBlock@)">
            <summary cref="M:Sigil.Emit`1.BeginCatchBlock(System.Type, Sigil.ExceptionBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.EndCatchBlock(Sigil.CatchBlock)">
            <summary cref="M:Sigil.Emit`1.EndCatchBlock(Sigil.CatchBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.BeginFinallyBlock(Sigil.ExceptionBlock)">
            <summary cref="M:Sigil.Emit`1.BeginFinallyBlock(Sigil.ExceptionBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.BeginFinallyBlock(Sigil.ExceptionBlock,Sigil.FinallyBlock@)">
            <summary cref="M:Sigil.Emit`1.BeginFinallyBlock(Sigil.ExceptionBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.EndFinallyBlock(Sigil.FinallyBlock)">
            <summary cref="M:Sigil.Emit`1.EndFinallyBlock(Sigil.FinallyBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.EndExceptionBlock(Sigil.ExceptionBlock)">
            <summary cref="M:Sigil.Emit`1.EndExceptionBlock(Sigil.ExceptionBlock)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.CreateDelegate">
            <summary cref="M:Sigil.Emit`1.CreateDelegate" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.CreateMethod">
            <summary cref="M:Sigil.Emit`1.CreateMethod" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.CreateConstructor">
            <summary cref="M:Sigil.Emit`1.CreateConstructor" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Add">
            <summary cref="M:Sigil.Emit`1.Add" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Add_Ovf">
            <summary cref="M:Sigil.Emit`1.AddOverflow" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Add_Ovf_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedAddOverflow" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.And">
            <summary cref="M:Sigil.Emit`1.And" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Beq(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.BranchIfEqual(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Bge(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.BranchIfGreaterOrEqual(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Bge_Un(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.UnsignedBranchIfGreaterOrEqual(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Bgt(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.BranchIfGreater(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Bgt_Un(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.UnsignedBranchIfGreater(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ble(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.BranchIfLessOrEqual(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ble_Un(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.UnsignedBranchIfLessOrEqual(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Blt(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.BranchIfLess(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Blt_Un(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.UnsignedBranchIfLess(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Bne_Un(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.UnsignedBranchIfNotEqual(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Box``1">
            <summary cref="M:Sigil.Emit`1.Box``1()" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Box(System.Type)">
            <summary cref="M:Sigil.Emit`1.Box(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Br(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.Branch(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Break">
            <summary cref="M:Sigil.Emit`1.Break" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Brfalse(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.BranchIfFalse(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Brtrue(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.BranchIfTrue(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Call(System.Reflection.MethodInfo)">
            <summary cref="M:Sigil.Emit`1.Call(System.Reflection.MethodInfo)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Calli(System.Reflection.CallingConventions,System.Type,System.Type[])">
            <summary cref="M:Sigil.Emit`1.CallIndirect(System.Reflection.CallingConventions,System.Type,System.Type[])" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Callvirt(System.Reflection.MethodInfo,System.Type)">
            <summary cref="M:Sigil.Emit`1.CallVirtual(System.Reflection.MethodInfo, System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Castclass``1">
            <summary cref="M:Sigil.Emit`1.CastClass``1" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Castclass(System.Type)">
            <summary cref="M:Sigil.Emit`1.CastClass(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ceq">
            <summary cref="M:Sigil.Emit`1.CompareEqual" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Cgt">
            <summary cref="M:Sigil.Emit`1.CompareGreaterThan" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Cgt_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedCompareGreaterThan" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ckfinite">
            <summary cref="M:Sigil.Emit`1.CheckFinite" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Clt">
            <summary cref="M:Sigil.Emit`1.CompareLessThan" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Clt_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedCompareLessThan" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Conv_Ovf_Un``1">
            <summary cref="M:Sigil.Emit`1.UnsignedConvertOverflow(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Conv_Ovf_Un(System.Type)">
            <summary cref="M:Sigil.Emit`1.UnsignedConvertOverflow(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Conv_R_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedConvertToFloat" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Conv``1">
            <summary cref="M:Sigil.Emit`1.Convert(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Conv(System.Type)">
            <summary cref="M:Sigil.Emit`1.Convert(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Conv_Ovf``1">
            <summary cref="M:Sigil.Emit`1.ConvertOverflow(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Conv_Ovf(System.Type)">
            <summary cref="M:Sigil.Emit`1.ConvertOverflow(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Cpblk(System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.CopyBlock(System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Cpobj``1">
            <summary cref="M:Sigil.Emit`1.CopyObject(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Cpobj(System.Type)">
            <summary cref="M:Sigil.Emit`1.CopyObject(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Div">
            <summary cref="M:Sigil.Emit`1.Divide" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Div_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedDivide" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Dup">
            <summary cref="M:Sigil.Emit`1.Duplicate" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Initblk(System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.InitializeBlock(System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Initobj``1">
            <summary cref="M:Sigil.Emit`1.InitializeObject(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Initobj(System.Type)">
            <summary cref="M:Sigil.Emit`1.InitializeObject(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Isinst``1">
            <summary cref="M:Sigil.Emit`1.IsInstance(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Isinst(System.Type)">
            <summary cref="M:Sigil.Emit`1.IsInstance(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Jmp(System.Reflection.MethodInfo)">
            <summary cref="M:Sigil.Emit`1.Jump(System.Reflection.MethodInfo)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldarg(System.UInt16)">
            <summary cref="M:Sigil.Emit`1.LoadArgument(System.Int32)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldarga(System.UInt16)">
            <summary cref="M:Sigil.Emit`1.LoadArgumentAddress(System.Int32)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldc(System.Boolean)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Boolean)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldc(System.Single)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Single)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldc(System.Double)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Double)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldc(System.UInt32)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.UInt32)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldc(System.Int32)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Int32)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldc(System.Int64)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Int64)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldc(System.UInt64)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.UInt64)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldelem">
            <summary cref="M:Sigil.Emit`1.LoadElement" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldelema">
            <summary cref="M:Sigil.Emit`1.LoadElementAddress" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldfld(System.Reflection.FieldInfo,System.Nullable{System.Boolean},System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.LoadField(System.Reflection.FieldInfo, System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldflda(System.Reflection.FieldInfo)">
            <summary cref="M:Sigil.Emit`1.LoadFieldAddress(System.Reflection.FieldInfo)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldftn(System.Reflection.MethodInfo)">
            <summary cref="M:Sigil.Emit`1.LoadFunctionPointer(System.Reflection.MethodInfo)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldind``1(System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.LoadIndirect(System.Type, System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldind(System.Type,System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.LoadIndirect(System.Type, System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldlen">
            <summary cref="M:Sigil.Emit`1.LoadLength" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldloc(Sigil.Local)">
            <summary cref="M:Sigil.Emit`1.LoadLocal(Sigil.Local)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldloca(Sigil.Local)">
            <summary cref="M:Sigil.Emit`1.LoadLocalAddress(Sigil.Local)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldnull">
            <summary cref="M:Sigil.Emit`1.LoadNull" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldobj``1(System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.LoadObject(System.Type, System.Boolen, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldobj(System.Type,System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.LoadObject(System.Type, System.Boolen, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldstr(System.String)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.String)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldtoken(System.Reflection.FieldInfo)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Reflection.FieldInfo)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldtoken(System.Reflection.MethodInfo)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Reflection.MethodInfo)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldtoken``1">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldtoken(System.Type)">
            <summary cref="M:Sigil.Emit`1.LoadConstant(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ldvirtftn(System.Reflection.MethodInfo)">
            <summary cref="M:Sigil.Emit`1.LoadVirtualFunctionPointer(System.Reflection.MethodInfo)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Leave(Sigil.Label)">
            <summary cref="M:Sigil.Emit`1.Leave(Sigil.Label)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Localloc">
            <summary cref="M:Sigil.Emit`1.LocalAllocate" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Mul">
            <summary cref="M:Sigil.Emit`1.Multiply" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Mul_Ovf">
            <summary cref="M:Sigil.Emit`1.MultiplyOverflow" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Mul_Ovf_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedMultiplyOverflow" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Neg">
            <summary cref="M:Sigil.Emit`1.Negate" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Newarr``1">
            <summary cref="M:Sigil.Emit`1.NewArray(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Newarr(System.Type)">
            <summary cref="M:Sigil.Emit`1.NewArray(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Newobj(System.Reflection.ConstructorInfo)">
            <summary cref="M:Sigil.Emit`1.NewObject(System.Reflection.ConstructorInfo)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Nop">
            <summary cref="M:Sigil.Emit`1.Nop" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Not">
            <summary cref="M:Sigil.Emit`1.Not" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Or">
            <summary cref="M:Sigil.Emit`1.Or" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Pop">
            <summary cref="M:Sigil.Emit`1.Pop" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Rem">
            <summary cref="M:Sigil.Emit`1.Remainder" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Rem_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedRemainder" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Ret">
            <summary cref="M:Sigil.Emit`1.Return" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Rethrow">
            <summary cref="M:Sigil.Emit`1.ReThrow" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Shl">
            <summary cref="M:Sigil.Emit`1.ShiftLeft" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Shr">
            <summary cref="M:Sigil.Emit`1.ShiftRight" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Shr_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedShiftRight" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Sizeof``1">
            <summary cref="M:Sigil.Emit`1.SizeOf(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Sizeof(System.Type)">
            <summary cref="M:Sigil.Emit`1.SizeOf(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Starg(System.UInt16)">
            <summary cref="M:Sigil.Emit`1.StoreArgument(System.Int32)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Stelem">
            <summary cref="M:Sigil.Emit`1.StoreElement" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Stfld(System.Reflection.FieldInfo,System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.StoreField(System.Reflection.FieldInfo, System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Stind``1(System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.StoreIndirect(System.Type, System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Stind(System.Type,System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.StoreIndirect(System.Type, System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Stloc(Sigil.Local)">
            <summary cref="M:Sigil.Emit`1.StoreLocal(Sigil.Local)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Stobj``1(System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.StoreObject(System.Type, System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Stobj(System.Type,System.Boolean,System.Nullable{System.Int32})">
            <summary cref="M:Sigil.Emit`1.StoreObject(System.Type, System.Boolean, System.Nullable&lt;int&gt;)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Sub">
            <summary cref="M:Sigil.Emit`1.Subtract" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Sub_Ovf">
            <summary cref="M:Sigil.Emit`1.SubtractOverflow" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Sub_Ovf_Un">
            <summary cref="M:Sigil.Emit`1.UnsignedSubtractOverflow" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Switch(Sigil.Label[])">
            <summary cref="M:Sigil.Emit`1.Switch(Sigil.Label[])" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Throw">
            <summary cref="M:Sigil.Emit`1.Throw" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Unbox``1">
            <summary cref="M:Sigil.Emit`1.Unbox(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Unbox(System.Type)">
            <summary cref="M:Sigil.Emit`1.Unbox(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Unbox_Any``1">
            <summary cref="M:Sigil.Emit`1.UnboxAny(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Unbox_Any(System.Type)">
            <summary cref="M:Sigil.Emit`1.UnboxAny(System.Type)" />
        </member>
        <member name="M:Sigil.EmitShorthand`1.Xor">
            <summary cref="M:Sigil.Emit`1.Xor" />
        </member>
        <member name="T:Sigil.ExceptionBlock">
            <summary>
            Represents an ExceptionBlock, which is roughly analogous to a try + catch + finally block in C#.
            
            To create an ExceptionBlock call BeginExceptionBlock().
            </summary>
        </member>
        <member name="P:Sigil.ExceptionBlock.Label">
            <summary>
            A label which marks the end of the ExceptionBlock.
            
            This Label is meant to be targetted by Leave() from anywhere except a FinallyBlock
            in the ExceptionBlock.
            
            Remember that it is illegal to branch from within an ExceptionBlock to outside.
            </summary>
        </member>
        <member name="T:Sigil.FinallyBlock">
            <summary>
            Represents a finally block, which appears within an ExceptionBlock.
            
            This is roughly analogous to `finally` in C#.
            </summary>
        </member>
        <member name="P:Sigil.FinallyBlock.ExceptionBlock">
            <summary>
            The ExceptionBlock this FinallyBlock appears as part of.
            </summary>
        </member>
        <member name="T:Sigil.Label">
            <summary>
            Represents a Label in a CIL stream, and thus a Leave and Branch target.
            
            To create a Label call DefineLabel().
            
            Before creating a delegate, all Labels must be marked.  To mark a label, call MarkLabel().
            </summary>
        </member>
        <member name="M:Sigil.Label.ToString">
            <summary>
            Equivalent to Name.
            </summary>
        </member>
        <member name="P:Sigil.Label.Name">
            <summary>
            The name of this Label.
            
            If one is omitted during creation a random one is created instead.
            
            Names are purely for debugging aid, and will not appear in the generated delegate.
            </summary>
        </member>
        <member name="T:Sigil.Local">
            <summary>
            Represents a variable local to the delegate being created.
            
            To create a Local, call DeclareLocal().
            </summary>
        </member>
        <member name="M:Sigil.Local.ToString">
            <summary>
            Returns the type and name of this Local, in string form.
            </summary>
        </member>
        <member name="M:Sigil.Local.Dispose">
            <summary>
            Frees this local.
            
            While not strictly required, freeing a local allows it's index to be reused.
            
            Locals are only elligible for reuse when the new local is exactly the same type.
            </summary>
        </member>
        <member name="P:Sigil.Local.Name">
            <summary>
            The name of this local.
            
            If one is omitted during creation a random one is created instead.
            
            Names are purely for debugging aid, and will not appear in the generated delegate.
            </summary>
        </member>
        <member name="P:Sigil.Local.LocalType">
            <summary>
            The type stored in this local.
            </summary>
        </member>
        <member name="T:Sigil.Impl.StackState">
            <summary>
            Keeps track of the types on the stack, allowing for type checking.
            </summary>
        </member>
        <member name="M:Sigil.Impl.TypeOnStack.ReplacedWith(Sigil.Impl.TypeOnStack)">
            <summary>
            When a type is replaced (without an opcode) on the stack, call this to keep
            any mark tracking working.
            </summary>
        </member>
        <member name="M:Sigil.Impl.TypeOnStack.Mark(System.Reflection.Emit.OpCode,System.Int32,System.Boolean)">
            <summary>
            Call to indicate that something on the stack was used
            as the #{index}'d (starting at 0) parameter to the {code} 
            opcode.
            </summary>
        </member>
        <member name="M:Sigil.Impl.TypeOnStack.CountMarks(System.Reflection.Emit.OpCode,System.Int32,System.Boolean)">
            <summary>
            Returns the # of times this value was used as the given #{index}'d parameter to the {code} instruction.
            </summary>
        </member>
        <member name="M:Sigil.Impl.TypeOnStack.CountMarks">
            <summary>
            Returns the total number of times this value was marked.
            </summary>
        </member>
        <member name="T:Sigil.SigilVerificationException">
            <summary>
            A SigilVerificationException is thrown whenever a CIL stream becomes invalid.
            
            There are many possible causes of this including: operator type mismatches, underflowing the stack, and branching from one stack state to another.
            
            Invalid arguments, non-sensical parameters, and other non-correctness related errors will throw more specific exceptions.
            
            SigilVerificationException will typically include the state of the stack (or stacks) at the instruction in error.
            </summary>
        </member>
        <member name="M:Sigil.SigilVerificationException.GetDebugInfo">
            <summary>
            Returns a string representation of any stacks attached to this exception.
            
            This is meant for debugging purposes, and should not be called during normal operation.
            </summary>
        </member>
        <member name="M:Sigil.SigilVerificationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Implementation for ISerializable.
            </summary>
        </member>
        <member name="M:Sigil.SigilVerificationException.ToString">
            <summary>
            Returns the message and stacks on this exception, in string form.
            </summary>
        </member>
    </members>
</doc>
